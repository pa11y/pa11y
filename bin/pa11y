#!/usr/bin/env node

// This file is part of pa11y.
//
// pa11y is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// pa11y is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with pa11y.  If not, see <http://www.gnu.org/licenses/>.

'use strict';

var extend = require('node.extend');
var path = require('path');
var pkg = require('../package.json');
var program = require('commander');
var pa11y = require('../lib/pa11y');
var readline = require('readline');
var async = require('async');
var chalk = require('chalk');
var fs = require('fs');
var crypto = require('crypto');

configureProgram(program);
runProgram(program);

function configureProgram(program) {
	program.version(pkg.version)
		.usage('[options] [url]')
		.option(
			'-s, --standard <name>',
			'the accessibility standard to use: Section508, WCAG2A, WCAG2AA (default), WCAG2AAA'
		)
		.option(
			'-r, --reporter <reporter>',
			'the reporter to use: cli (default), csv, html, json',
			'cli'
		)
		.option(
			'-o, --output <output>',
			'filename that will receive the output (special keyword: %HASH%, representing the hash of the current URL)'
		)
		.option(
			'-l, --level <level>',
			'the level of message to fail on (exit with code 2): error, warning, notice',
			'error'
		)
		.option(
			'-T, --threshold <name>',
			'the number of errors to permit before failing',
			'0'
		)
		.option(
			'-i, --ignore <ignore>',
			'types and codes of messages to ignore separated by semi-colons'
		)
		.option(
			'-c, --config <path>',
			'a JSON config file',
			'./pa11y.json'
		)
		.option(
			'-p, --port <port>',
			'the port to run PhantomJS on'
		)
		.option(
			'-t, --timeout <ms>',
			'the timeout in milliseconds'
		)
		.option(
			'-w, --wait <ms>',
			'the time to wait before running tests in milliseconds'
		)
		.option(
			'-d, --debug',
			'output debug messages'
		)
		.option(
			'-H, --htmlcs <url>',
			'the URL or path to source HTML_CodeSniffer from'
		)
		.option(
			'-e, --phantomjs <path>',
			'the path to the phantomjs executable'
		)
		.option(
			'-0, --stdin',
			'read URL from stdin'
		)
		.parse(process.argv);
	program.url = program.args[0] || null;
}

function runTest(test, options, url, callbacks) {
	processOutput(options.output, url);
	options.log.begin(url);
	try {
		test.run(url, function(error, results) {
			if (error) {
				options.log.error(error.stack);
				return callbacks.error(error);
			}
			options.log.results(results, url);
			if (reportShouldFail(program.level, results, program.threshold)) {
				return callbacks.error(error);
			}
			callbacks.complete(results);
		});
	} catch (error) {
		options.log.error(error.stack);
		process.exit(1);
	}
}

function getRunQueue(test, options) {
	var hasErrors = false;
	var urls = async.queue(
		function(task, onTaskComplete) {
			if (program.reporter === 'cli') {
				console.log('\n' + chalk.black.bgYellow('Compute ' + task.url + '\n\n'));
			}
			runTest(
				test,
				options,
				task.url,
				{
					complete: function(results) {
						onTaskComplete(null, results);
					},
					error: function(error) {
						hasErrors = true;
						onTaskComplete(error);
					}
				}
			);
		},
		1
	);
	urls.drain = function() {
		if (hasErrors) {
			process.on('exit', function() {
				process.exit(2);
			});
		}
	};
	return urls;
}

function runProgram(program) {
	var options = processOptions(program);
	var test = pa11y(options);

	if (program.url) {
		runTest(
			test,
			options,
			program.url,
			{
				complete: process.exit.bind(null, 0),
				error: function() {
					process.once('exit', function() {
						process.exit(2);
					});
				}
			}
		);
	} else if (program.stdin) {
		var urls = getRunQueue(test, options);
		readline.createInterface(process.stdin, undefined).on('line', function(url) {
			urls.push({url: url});
		});
	} else {
		program.help();
	}
}

function processOptions(program) {
	var options = extend(true, {}, loadConfig(program.config), {
		htmlcs: program.htmlcs,
		ignore: (program.ignore ? program.ignore.split(';') : undefined),
		log: loadReporter(program.reporter),
		output: program.output,
		page: {
			settings: {
				resourceTimeout: program.timeout
			}
		},
		phantom: {
			path: program.phantomjs,
			port: program.port
		},
		standard: program.standard,
		timeout: program.timeout,
		wait: program.wait
	});
	if (!program.debug) {
		options.log.debug = function() {};
	}
	return options;
}

function loadConfig(filePath) {
	return requireFirst([
		filePath,
		filePath.replace(/^\.\//, process.cwd() + '/'),
		process.cwd() + '/' + filePath
	], {});
}

function loadReporter(name) {
	var reporter = requireFirst([
		'../reporter/' + name,
		'pa11y-reporter-' + name,
		path.join(process.cwd(), name)
	], null);
	if (!reporter) {
		console.error('Reporter "' + name + '" could not be found');
		process.exit(1);
	}
	return reporter;
}

function processOutput(output, url) {
	if (!output) {
		return;
	}
	var hash = output.replace(/%HASH%/, crypto.createHash('sha1').update(url).digest('hex'));
	var outputStream = fs.createWriteStream(hash);
	console.log = function(message) {
		outputStream.write(message);
	};
}

function requireFirst(stack, defaultReturn) {
	if (!stack.length) {
		return defaultReturn;
	}
	try {
		return require(stack.shift());
	} catch (error) {
		return requireFirst(stack, defaultReturn);
	}
}

function reportShouldFail(level, results, threshold) {
	if (level === 'none') {
		return false;
	}
	if (level === 'notice') {
		return (results.length > threshold);
	}
	if (level === 'warning') {
		return (results.filter(isWarningOrError).length > threshold);
	}
	return (results.filter(isError).length > threshold);
}

function isError(result) {
	return (result.type === 'error');
}

function isWarningOrError(result) {
	return (result.type === 'warning' || result.type === 'error');
}
